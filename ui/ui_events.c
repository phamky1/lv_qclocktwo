// This file was generated by SquareLine Studio
// SquareLine Studio version: SquareLine Studio 1.5.0
// LVGL version: 9.1.0
// Project name: licheeMac

#include "ui.h"

#include <stdio.h>
#include <string.h>
#include <time.h>

#include <stdio.h>
#include <string.h>

#include <stdio.h>
#include <string.h>

#define RANDOM_CHAR_TIMER       30
#define RANDOM_CHAR_TIMER_CNT_MAX (5000 / RANDOM_CHAR_TIMER)
#define TIMER_UPDATE_INTERVAL   60000

int16_t init_counter = RANDOM_CHAR_TIMER_CNT_MAX;

#define QLOCK_LENGTH 121

#define ROWS 10
#define COLS 12
// Global Qlocktwo matrix
/*               123456789012    */
char matrix[] = "ITLISASAMPM\n"   // 1
                "ACQUARTERDC\n"   // 2
                "TWENTYFIVEX\n"   // 3
                "HALFBTENFTO\n"   // 4
                "PASTERUNINE\n"   // 5
                "ONESIXTHREE\n"   // 6
                "FOURFIVETWO\n"   // 7
                "EIGHTELEVEN\n"   // 8
                "SEVENTWELVE\n"   // 9
                "TENSEOCLOCK\n";  // 10

// Lookup table for minute phrases
typedef struct {
    int start1;
    int length1;
    int start2;
    int length2;
    int start3;
    int length3;
} min_pharse_t;

#define POS(row, col)  (row-1)*COLS+ + (col-1)

min_pharse_t minute_phrases[] = {
    { POS(10,6) , 6, -1, -1, -1, -1 }, // OCLOCK
    { POS(7,5)  , 4, POS(5, 1), 4, -1, -1 }, // FIVE PAST
    { POS(4,6)  , 3, POS(5,1), 4, -1, -1 }, // TEN PAST
    { POS(2,3)  , 7, POS(5,1), 4, -1, -1 }, // QUARTER PAST
    { POS(3,1)  , 6, POS(5,1), 4, -1, -1 }, // TWENTY PAST
    { POS(3,1)  , 6, POS(3,7), 4, POS(5,1), 4 }, // TWENTY FIVE PAST
    { POS(4,1)  , 4, POS(5,1), 4, -1, -1 }, // HALF PAST
    { POS(3,1)  , 6, POS(3,7), 4, POS(4,10), 2 }, // TWENTY FIVE TO
    { POS(3,1)  , 6, POS(4,10), 2, -1, -1 }, // TWENTY TO
    { POS(2,3)  , 7, POS(4,10), 2, -1, -1 }, // QUARTER TO
    { POS(4,6)  , 3, POS(4,10), 2, -1, -1 }, // TEN TO
    { POS(3,7)  , 4, POS(4,10), 2, -1, -1 } // FIVE TO
};

typedef struct {
	int start;
	int length;
} hour_word_t;

// Lookup table for hour POSs
hour_word_t hour_words[] = {
	{ POS(9,6), 6 }, // TWELVE
	{ POS(6,1), 3 }, // ONE
	{ POS(7,9), 3 }, // TWO
	{ POS(6,7), 5 }, // THREE
	{ POS(7,1), 4 }, // FOUR
	{ POS(7,5), 4 }, // FIVE
	{ POS(6,4), 3 }, // SIX
	{ POS(9,1), 5 }, // SEVEN
	{ POS(8,1), 5 }, // EIGHT
	{ POS(5,8), 4 }, // NINE
	{ POS(10,1), 3 }, // TEN
	{ POS(8,6), 6 } // ELEVEN
};

char display_matrix[QLOCK_LENGTH] = {0};

void replace_characters_with_spaces() {
    for (int i = 0; i < QLOCK_LENGTH; i++) {
        if (matrix[i] == '\n') {
            display_matrix[i] = '\n';
        } else {
            display_matrix[i] = ' ';
        }
    }
}

void highlight_word(int start, int length) {
    memcpy(&display_matrix[start], &matrix[start], length);
}

void highlight_phrase(int minute) {
    if (minute >= 0 && minute < 60) {
        min_pharse_t* phrase = &minute_phrases[minute / 5];
        printf("Phrase: %d - %d - %d\n", phrase->start1, phrase->start2, phrase->start3);
        if (phrase->start1 >= 0) highlight_word(phrase->start1, phrase->length1);
        if (phrase->start2 >= 0) highlight_word(phrase->start2, phrase->length2);
        if (phrase->start3 >= 0) highlight_word(phrase->start3, phrase->length3);
    }
}

void display_qclocktwo_time(int hour, int minute) {
    // Reset the display matrix to spaces
    replace_characters_with_spaces();

    // Define the basic phrase locations
    highlight_word(0, 2);  // IT
    highlight_word(3, 2);  // IS

    // Highlight the minute phrase
    highlight_phrase(minute);

    // Determine the hour
    if (minute >= 35) {
        hour = (hour + 1) % 12;
    }

    // Highlight the hour
    highlight_word(hour_words[hour % 12].start, hour_words[hour % 12].length);

    // Print the result for demonstration purposes
    for (int i = 0; i < ROWS; i++) {
        for (int j = 0; j < COLS; j++) {
            printf("-%c.", display_matrix[i * COLS + j]);
        }
    }
}

// Function to get the current time and format it for Qlocktwo
void update_qclocktwo_time(lv_obj_t* label)
{
    time_t rawtime;
    struct tm* timeinfo;
    char buffer[256];

    time(&rawtime);
    timeinfo = localtime(&rawtime);

    display_qclocktwo_time(timeinfo->tm_hour, timeinfo->tm_min);
    lv_label_set_text(label, display_matrix);
}

void highlight_random_chars()
{
    srand(time(NULL)); // Seed the random number generator
    for (int i = 0; i < QLOCK_LENGTH - 1; i++) {
        if (matrix[i] == '\n') {
            display_matrix[i] = '\n'; // Random char from 'A' to 'Z'
        } else if (matrix[i] != ' ') {
            display_matrix[i] = (rand() % 26) + 0x41; // Random char from 'A' to 'Z'
        } else {
            display_matrix[i] = ' ';
        }
    }
}

void test_display_qclocktwo_time()
{
{
    static int hour = 0;
    static int minute = 0;

    display_qclocktwo_time(hour, minute);
    printf("Time: %02d:%02d\n", hour, minute);

    // Increment minute and adjust hour if necessary
    minute+=5;
    if (minute == 60) {
        minute = 0;
        hour++;
        if (hour == 12) {
            hour = 0;
        }
    }
}
}

// Timer callback function
static void timer_callback(lv_timer_t* timer)
{
    lv_obj_t* label = timer->user_data;
    if (init_counter > 0) {
        init_counter--;
        highlight_random_chars();
        lv_label_set_text(label, display_matrix);
    } else if (init_counter == 0) {
        init_counter = -1;
        _ui_opacity_set(ui_qClockTwo_Background, 255);
        update_qclocktwo_time(label);
        lv_timer_set_period(timer, TIMER_UPDATE_INTERVAL);
    } else {
        update_qclocktwo_time(label);
    }

	// /* Test Sequence */
    // test_display_qclocktwo_time();
    // lv_label_set_text(label, display_matrix);
}

void qClockTwo_init(lv_event_t* e)
{
    // Your code here
    printf("qClockTwo_init");
    init_counter = RANDOM_CHAR_TIMER_CNT_MAX;
    _ui_opacity_set(ui_Time_Text, 255);
    _ui_opacity_set(ui_qClockTwo_Background, 0);
    lv_timer_t* timer = lv_timer_create(timer_callback, RANDOM_CHAR_TIMER, ui_Time_Text);

    /* Test Sequence */

    // _ui_opacity_set(ui_qClockTwo_Background, 255);
    // lv_timer_t* timer = lv_timer_create(timer_callback, 2000, ui_Time_Text);
}
